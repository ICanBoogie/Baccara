<?php

namespace ICanBoogie\Baccara\Command;

use ICanBoogie\Application;
use ICanBoogie\HTTP\Request;

class OptimizeCommand extends AbstractCommand
{
    public function __invoke(array $args)
    {
        /*
        $boot = 'Icybee\boot';

        if (!function_exists($boot))
        {
            $boot = 'ICanBoogie\boot';
        }
		*/
        $routes = [

            '/api/ping/',
            '/'

        ];

#

        $root = getcwd();
        $root_length = strlen($root);
	    $relative_pathname = 'vendor/icanboogie-combined.php';
	    $destination = $root . DIRECTORY_SEPARATOR . $relative_pathname;

	    if (file_exists($destination))
	    {
		    echo "Unlink previous file: $relative_pathname\n";

		    unlink($destination);
	    }


        require $root . DIRECTORY_SEPARATOR . 'vendor/autoload.php';

	    $initial_classes = get_declared_classes();
	    $initial_traits = get_declared_traits();
	    $initial_interfaces = get_declared_interfaces();

	    $app = $this->baccara->app;

#

        new Application\ClearCacheEvent($app);

        foreach ($routes as $route)
        {
            $request = Request::from($route);

            try
            {
                $request();
            }
            catch (\Exception $e)
            {
                echo "Error on route $route: " . $e->getMessage() . PHP_EOL;
            }
        }

#

        $final_classes = get_declared_classes();
        $final_traits = get_declared_traits();
        $final_interfaces = get_declared_interfaces();

        $loaded_classes = array_diff($final_classes, $initial_classes);
        $loaded_traits = array_diff($final_traits, $initial_traits);
        $loaded_interfaces = array_diff($final_interfaces, $initial_interfaces);

        /* @var $reflections \ReflectionClass[] */

        $reflections = [];

        foreach (array_merge($loaded_interfaces, $loaded_traits, $loaded_classes) as $class_name)
        {
            $reflection = new \ReflectionClass($class_name);
            $reflections[$class_name] = $reflection;
        }

        $weights = array_combine(array_keys($reflections), array_fill(0, count($reflections), null));

        $compute_weights = function(\ReflectionClass $class, $depth = 0) use (&$reflections, &$weights, &$compute_weights) {

            $tab = str_repeat(' ', $depth * 3);
            $class_name = $class->name;

            $w = $weights[$class_name];

            if ($w !== null)
            {
                echo $tab . "-> $w ($class_name, already computed)\n";

                return $w;
            }

            echo $tab . "Compute weight for: $class_name\n";

            $w = 0;

            if ($class->isTrait())
            {
                foreach ($reflections as $reflection)
                {
                    foreach ($reflection->getTraits() as $trait)
                    {
                        if ($trait->name !== $class_name)
                        {
                            continue;
                        }

                        $w += 1 + $compute_weights($reflection, $depth + 1);
                    }
                }
            }
            else if ($class->isInterface())
            {
                foreach ($reflections as $reflection)
                {
                    foreach ($reflection->getInterfaces() as $interface)
                    {
                        if ($interface->name !== $class_name)
                        {
                            continue;
                        }

                        $w += 1 + $compute_weights($reflection, $depth + 1);
                    }
                }
            }
            else
            {
                foreach ($reflections as $reflection)
                {
                    $parent = $reflection->getParentClass();

                    if (!$parent || $parent->name != $class_name)
                    {
                        continue;
                    }

                    $w += 1 + $compute_weights($reflection, $depth + 1);
                }
            }

            echo $tab . "-> $w ($class->name)\n";

            $weights[$class_name] = $w;

            return $w;
        };


        foreach ($reflections as $class)
        {
            $compute_weights($class);
        }

        arsort($weights);

	    echo implode("\n", array_keys($weights)) . "\n";

        $files = [];

        foreach (array_keys($weights) as $class_name)
        {
            $files[] = $reflections[$class_name]->getFileName();
        }

        $files = array_unique($files);
        $strip_root = function($path) use ($root_length) {
            return substr($path, $root_length);
        };

        $imploded_files = ' * ' . implode("\n * ", array_map($strip_root, $files));
        $count = count($files);

        $combined = <<<EOT
<?php

/*
 * Automatically generated by ICanBoogie, using the following $count files:
 *
$imploded_files
 */

EOT;

        foreach ($files as $filename)
        {
            $contents = file_get_contents($filename);
            $tokens = token_get_all($contents);
            $cleaned = '';
            $has_namespace = false;

            foreach ($tokens as $token)
            {
                if (is_string($token))
                {
                    $cleaned .= $token;

                    continue;
                }

                list($token_id, $token_value) = $token;

                if (in_array($token_id, [ T_CLOSE_TAG, T_COMMENT, T_OPEN_TAG ]))
                {
                    continue;
                }

                if (in_array($token_id, [ T_DIR, T_FILE ]))
                {
                    $cleaned = '';

                    echo "Skipping " . $strip_root($filename) . ", found $token_value\n";

                    break;
                }

                if ($token_id === T_NAMESPACE)
                {
                    $has_namespace = true;
                }

                $cleaned .= $token_value;
            }

            if (!$has_namespace)
            {
                echo "Skipping " . $strip_root($filename) . ", no namespace\n";

                continue;
            }

            $combined .= $cleaned;
        }

        file_put_contents('vendor/icanboogie-combined.php', $combined);
    }
}
